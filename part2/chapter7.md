![ch7](../img/chapter7.png)

# 第七章：事务

> 一些创作者声称，出于一些性能和可用性的考虑，对通用的两阶段提交提供支持的代价是高昂的。我们有理由相信通过应用程序处理事务，总好过通过业务代码来处理繁杂的事务。
>
> — James Corbett 等.*Spanner: Google 全球分布式数据库* (2012)



在一个苛刻的数据系统中，很多事情都有可能出错：

* 数据库系统或者硬件系统随时可能出现故障（包括在写操作的过程中）。
* 应用系统随时可能崩溃（包括在执行一系统操作的途中）
* 网络中断将意外的断开应用和数据库或数据库其中一个节点的连接。
* 客户端服务可能同时对数据库执行写操作，导致彼此更改的数据被覆盖。
* 客户端可能感知不到只有部分更新成功的数据。
* 客户端之间的竞态可能导致的奇怪异常。

​    为了可靠性，系统必须处理这些缺陷从而保证他们不会对整个系统造成灾难性故障。然而，实现这些容错机制是一项重大的工程。它要求我们对所有可能出现异常的做出缜密的思考，以及需要做大量的测试来确保这些解决方案是真实有效的。

近十年来，**事务(transaction)** 机制都是作为简化这些问题的首选。事务机制可作为应用程序将一组读写操作当作一个整体逻辑单元来执行的一种可行方式。从概念上讲，一个事务中包含的所有读写操作都可看作一个整体:要么执行成功（commit **提交**），要么执行失败（abort **中止**、rollback **回滚**）。如果失败，应用程序可以安全的执行**重试**（retry）操作。有了事务，对应用来说处理异常将变得异常简单，因为应用不需要关心诸如：“一部分操作成功、一部分操作失败（不管出于什么原因）”的这种局部失败的状况。

​    如果你在工作中有过几年使用事务的体验，我们会下意识感觉事务是自然存在的，但事实是事务处理并不是凭空产生的，我们并不能理所当然的认为它就应该存在；他是为了简化应用程序访问数据库的编程模型而主动创建的。通过事务，应用程序可以不用关心并发问题以及一些其它潜在的错误场景，因为数据库替你做了这些工作（我们称之为 **安全担保-(safety guarantees)** ）;

​    其实并不是所有的应用都需要用到事务，有些时候弱化甚至完全放弃事务担保反而会更加有优势（例如：为了实现高性能或高可用）。甚至于说一些安全特性是可以在没有事务的情况来实现的。

​    那么我们怎么判断在什么情况下才需要事务呢？为了回答这个问题，我们首先需要明白越严格的事务担保机制，所花费的成本也就越高。尽管事务机制乍一看很简单，但实际上很多工作都被巧妙的隐藏在了实现细节之中了。

在这一章，我们会列举多个引发错误的示例，来探讨数据库用来防止出现这些错误的标准解决方案。我们会特别深入到 **并发控制** 领域，讨论各种可能引发的 **竞态条件** ，以及数据库是怎样实现如 **读已提交**（*read committed*）、**镜像隔离**（*snapshot isolation*）、**串行化**（*serializability*）等隔离级别的。

本章的讨论对于单机和分布式数据库都适用；到了[第八章](../part2/chapter8.md) 我们会专注于讨论仅在分布式系统中出现的一些特殊挑战。

## **事务的晦涩概念**

​    在今天，几乎所有的关系型数据库以及一些非关系型数据库都支持事务。他们中大多数都延用了IBM公司在1975年发布的第一款**SQL数据库**[1,2,3]- **IBM System R**系统的风格。尽管有一些实现细节的差异，但是基本思路在40年来几乎没有改变：MySQL，PostgreSQL，Oracle，SQL Server这些数据库上所支持的事务都与 **System R** 有着惊人的相似度。

​    在21世纪末，非关系型（**NoSQL**）数据库开始逐渐流行。他们旨在基于关系型数据库的基础之上，面对新的 **数据模型**（参见：[第二章](../part1/chapter2.md)）提供另一种默认包含**副本**（[第五章](pather5.md)）、**分区**（[第六章](pather6.md)）机制的选择。事务则成为了这次创新历程中的牺牲品：很多新一代的数据库完全摒弃或以一个相比我们之前理解要弱的多的保证机制重新定义了事务[4]。

​    随着这些分布式数据库越来越受到追捧，人们开始普遍感觉事务是阻碍可伸缩性性的最大敌人，并且坚信任何大型系统想要保证高性能和高可用就必须放弃使用事务[5,6]。另一方面，一些数据库服务商提出的事务保证是体现“重要应用”和“价值数据”的最起码要求这种观点，也被认为是纯粹的危言耸听。

​    但事实并没有这么简单：与其它所有技术一样，事务也有它的优势和局限性。为了弄清它其中所做的权衡，让我们深入到事务在常规操作以及各种极端情况（确实存在）下所提供保障的细节中一探究竟。

### ACID的含义

​    事务提供的安全保证，通常会被描述成我们所熟知的代表着“**原子性**”（*Atomicity*），“**一致性**”（*Consistency*），“**隔离性**”（*Isolation*）和“**持久性**”（*Durability*）的首字母缩写-**ACID**。它是在1983年由Theo Härder 和 Andreas Reuter [7]提出来，旨在为数据库构建容错机制的精确术语。

然而，在实践中，不同的数据库对ACID的实现不尽相同，例如，正如我们所看到的，对于“**隔离性**”的含义就存在着很多争议性[8]。理想很丰满...，但魔鬼往往隐藏在细节中。如今，当一个系统宣称他是“遵从ACID”的，我们并不能很确切的知道它到底给我们带来了哪些保证。

#### **原子性**

​    通常，原子描述的是一些不能够再分解为更细小部分的物体。这个词在计算机的不同的领域描述的意思大致相同但却又有些微妙的变化在其中。例如：在多线程程序中，如果一个线程执行一个原子性操作，那么就意味着另一个线程是不能在当前线程未执行完成之前读取到任何中间态的结果的。系统的状态只存在操作前态和操作后态，中间不会出现其它状态。

​    相比之下，在ACID的语境下，“**原子性**”（atomicity）与并发无关。它不是描述多个进程试图同时访问相同数据的场景，这其实是接下来 ACID中的 **I- isolation ** （[隔离性](#isolation)）所涵盖的问题。

​    相反，原子性描述的是多个客户端想要同时进行多次写操作，而在这些写操作的过程中，由于一些诸如进程崩溃，网络连接中断，磁盘空间不足，或者违反完整性约束之类原因而引发异常的场景。如果这些写操作可以组合到一个原子性的事务当中，当事务执行过程中出现异常情况没有执行完成（*已提交-committed*），事务将终止（*aborted*）执行，数据库将撤销或丢弃这之前已经执行的操作。

​    假设没有原子性，那么当我们执行多个变更动作的过程中突然发生错误，我们将很难分辨出哪些变更会对业务产生影响，哪些不会。如果这时候应用程序尝试再重新执行一次，是极有可能会重复之前的操作的，这样就会导致相同的变更被执行了两次，从而导致数据重复或失实。但是有了原子性机制这个问题是不是就变得简单的多了：如果事务被终止，应用程序可以保证没有任何改变发生，所以也就可以很坦然的进行重试操作了。

在错误发生时能够中止并且丢弃掉该事务之前所执行操作的这样一种能力，是 ACID 原子性的特性。或许“**可中止性**”（*abortability*）比起“**原子性**”（*atomicity*）可以描述的更加贴切，但是我们依旧会沿用“**原子性**”（*atomicity*）这个有共识性的词汇。

#### **一致性**

”**一致性**“这个词的含义太宽泛了:

* 在 [第五章](chapter5.md) 中我们讨论了异步复制系统中副本复制的最终一致性问题（参见：[第5章：延迟同步问题](chapter5#迟同步问题)）。
* 一些系统使用一致性哈希算法来进行分区重平衡 (参见： [第6章：一致性哈希](chapter6.md) )。
* 在CAP定理中（[第九章](chapter9.md)），一致性描述的是线性一致（参见：[第九章：线性一致](chapter9.md)）。
* 在 ACID 中，一致性则是指数据库应用处于“预期状态”的明确定义。

一个词竟然可以有4种完全不同的含义不见的是一件好事。

​    ACID一致性的概念是指在任何时候都会对你所操作的数据都要施加一个特定约束来保证它在逻辑上的“**不变性**”（*invariants*），例如在一个记账系统中，一个账户中的借款记录和贷款记录是始终保持收支平衡的。如果一个事务从一个有效的“**不变性**”状态开始，并且在这期间都根据特定约束保持着这种不变性的逻辑，那么最终的结果也必然也是符合这种“**不变性**”逻辑的。

​    然而，这种一致性的实现依赖于应用控制变量，它是通过应用定义操作规范来保证事务的正确性来实现一致性的。这些都不是通过数据库来保证的：即使你写入的数据可能打破这个这个"不变量"，数据库也不会拒绝写入（一些特殊情况的“不变性”还是能够被检测出来的，比如通过外键约束或者通过唯一主键约束，然而，通常情况下数据的有效和无效性是由应用定义的，而数据库仅仅是存储它们而已）。

​    “**原子性**”，“**隔离性**”和“**持久化性**”是数据库的特性，至于“**一致性**”（在ACID的角度）它是归属于应用。应用可以依靠数据的原子性和隔离性来实现一致性，它不是仅靠数据库的能力就能实现的，所以从某种意义上来说“C”，也就是一致性，其实并不能把它纳入ACID的范畴。

#### <a id="isolation">隔离性</a>

​    大多数数据库都会在同一时间接入多个客户端。如果这些客户端分别请求数据库的不同数据是没有问题的，但是如果它们访问的是相同的数据库记录，这时候可能就会出现并发问题（*竞态条件*）。

​    <font color="red"> 图7-1</font> 是这类问题的一个示例，如果说有两个客户端同时对数据库里的一条计数信息执行递增，每个客户端的步骤为：读出当前值，加1，然后把计算的新值写回（这里假定数据库本身不具备内建的自增操作能力）。在<font color="red"> 图7-1</font>中，因为发生了两次自增操作，所以我们寄希望于计数值由42增加到44，但实际上由于竟态条件的原因，计数值只增加到了43。

在ACID的场景中，“**隔离性**”意味着并发执行的操作相互之间是隔离的：彼此之间不能相互干扰。传统的数据库教科书把隔离性具象化为“**串行化**”（*serializability*），也就是说每一个事务在执行过程中都可以认为在当前的整个数据库中只有自己一个事务在执行。尽管在现实中事务的执行大抵都是并发执行的，但是数据库需要保证所有的事务提交后，执行的结果和事务按照顺序一个接一个执行的结果保持一致[10]。

![](../img/chapter7-1.png)

*图 7-1. 两个客户端同时对同一个计数值增加场景的竟态条件*

然而，通常情况下串行化的隔离策略很少被使用，其根本原因在于它会对性能产生负面影响。像Oracle 11g这些主流的数据库中，甚至完全摒弃了这部分功能。尽管Oracle中有一个称之为“**序列化**”的隔离级别，但实际上它的实现方式是一种相较于序列化弱的多的担保机制，叫做“**快照隔离**”（*snapshot isolation*）[8,11]。我们将在[**弱隔离级别**]()这一小节再展开对“镜像隔离”以及“其它形式的隔离”的讨论。



#### 持久化性



