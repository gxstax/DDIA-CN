![ch7](../img/chapter7.png)

# 第七章：事务

> 一些创作者声称，出于一些性能和可用性的考虑，对通用的两阶段提交提供支持的代价是高昂的。我们有理由相信通过应用程序处理事务，总好过通过业务代码来处理繁杂的事务。
>
> — James Corbett 等.*Spanner: Google 全球分布式数据库* (2012)



在一个苛刻的数据系统中，很多事情都有可能出错：

* 数据库系统或者硬件系统随时可能出现故障（包括在写操作的过程中）。
* 应用系统随时可能崩溃（包括在执行一系统操作的途中）
* 网络中断将意外的断开应用和数据库或数据库其中一个节点的连接。
* 客户端服务可能同时对数据库执行写操作，导致彼此更改的数据被覆盖。
* 客户端可能感知不到只有部分更新成功的数据。
* 客户端之间的竞态可能导致的奇怪异常。

​    为了可靠性，系统必须处理这些缺陷从而保证他们不会对整个系统造成灾难性故障。然而，实现这些容错机制是一项重大的工程。它要求我们对所有可能出现异常的做出缜密的思考，以及需要做大量的测试来确保这些解决方案是真实有效的。

近十年来，**事务(transaction)** 机制都是作为简化这些问题的首选。事务机制可作为应用程序将一组读写操作当作一个整体逻辑单元来执行的一种可行方式。从概念上讲，一个事务中包含的所有读写操作都可看作一个整体:要么执行成功（commit **提交**），要么执行失败（abort **中止**、rollback **回滚**）。如果失败，应用程序可以安全的执行**重试**（retry）操作。有了事务，对应用来说处理异常将变得异常简单，因为应用不需要关心诸如：“一部分操作成功、一部分操作失败（不管出于什么原因）”的这种局部失败的状况。

​    如果你在工作中有过几年使用事务的体验，我们会下意识感觉事务是自然存在的，但事实是事务处理并不是凭空产生的，我们并不能理所当然的认为它就应该存在；他是为了简化应用程序访问数据库的编程模型而主动创建的。通过事务，应用程序可以不用关心并发问题以及一些其它潜在的错误场景，因为数据库替你做了这些工作（我们称之为 **安全担保-(safety guarantees)** ）;

​    其实并不是所有的应用都需要用到事务，有些时候弱化甚至完全放弃事务担保反而会更加有优势（例如：为了实现高性能或高可用）。甚至于说一些安全特性是可以在没有事务的情况来实现的。

​    那么我们怎么判断在什么情况下才需要事务呢？为了回答这个问题，我们首先需要明白越严格的事务担保机制，所花费的成本也就越高。尽管事务机制乍一看很简单，但实际上很多工作都被巧妙的隐藏在了实现细节之中了。

在这一章，我们会列举多个引发错误的示例，来探讨数据库用来防止出现这些错误的标准解决方案。我们会特别深入到 **并发控制** 领域，讨论各种可能引发的 **竞态条件** ，以及数据库是怎样实现如 **读已提交**（*read committed*）、**镜像隔离**（*snapshot isolation*）、**串行化**（*serializability*）等隔离级别的。

本章的讨论对于单机和分布式数据库都适用；到了[第八章](../part2/chapter8.md) 我们会专注于讨论仅在分布式系统中出现的一些特殊挑战。

